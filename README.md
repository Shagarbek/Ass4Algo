# Graph Algorithms Performance Report  
**Algorithms:** Tarjan (SCC), Kahn (Topological Sort), DAG Shortest & Longest Paths  

---

## 1. Data Summary

This project benchmarks graph algorithms on several datasets of varying size and density.  
All graphs were either **DAGs**, **cyclic**, or **mixed**, with **positive random edge weights**.

| Dataset | Vertices (n) | Edges (m) | Structure | Weight Model |
|----------|--------------|------------|------------|---------------|
| small_01_dag.json | 6 | 7 | DAG | Uniform(1–10) |
| small_02_cycle.json | 6 | 18 | Cyclic | Uniform(1–10) |
| small_03_mixed.json | 8 | 22 | Mixed | Uniform(1–10) |
| medium_01_mixed.json | 12 | 46 | Mixed | Uniform(1–10) |
| medium_02_dense.json | 14 | 127 | Dense | Uniform(1–10) |
| medium_03_sparse.json | 11 | 22 | Sparse | Uniform(1–10) |
| large_01_perf_sparse.json | 25 | 24 | Sparse | Uniform(1–10) |
| large_02_perf_dense.json | 20 | 95 | Dense | Uniform(1–10) |
| large_03_random.json | 30 | 69 | Random | Uniform(1–10) |

---

## 2. Results

### 2.1 DAG Shortest and Longest Paths

| Graph | n | Edges | Source | Shortest Time | Longest Time | Critical Length | Critical Path |
|-------|---:|------:|-------:|---------------:|--------------:|----------------:|----------------|
| large_01_perf_sparse.json | 25 | 24 | 0 | 0.832 ms | 0.685 ms | 114.0 | [0 → ... → 24] |
| large_02_perf_dense.json | 20 | 95 | 18 | 0.305 ms | 0.128 ms | 0.1 | [18] |
| large_03_random.json | 30 | 69 | 0 | 0.174 ms | 0.162 ms | 125.0 | [0 → ... → 29] |
| medium_01_mixed.json | 12 | 46 | 8 | 0.203 ms | 0.182 ms | 0.1 | [8] |
| medium_02_dense.json | 14 | 127 | 12 | 0.183 ms | 0.131 ms | 0.1 | [12] |
| medium_03_sparse.json | 11 | 22 | 0 | 0.052 ms | 0.055 ms | 54.0 | [0 → ... → 10] |
| small_01_dag.json | 6 | 7 | 0 | 0.025 ms | 0.109 ms | 32.0 | [0 → ... → 5] |
| small_02_cycle.json | 6 | 18 | 3 | 0.171 ms | 0.115 ms | 0.1 | [3] |
| small_03_mixed.json | 8 | 22 | 5 | 0.164 ms | 0.125 ms | 0.1 | [5] |

---

### 2.2 Tarjan (SCC) and Kahn (Topological Sort)

| Graph | n | Edges | SCC Count | Condensed Nodes | Condensed Edges | Kahn Pushes | Kahn Pops | Topo Time (ms) |
|-------|---:|------:|-----------:|----------------:|----------------:|-------------:|-----------:|---------------:|
| large_01_perf_sparse.json | 25 | 24 | 25 | 25 | 24 | 25 | 25 | 0.921 |
| large_02_perf_dense.json | 20 | 95 | 1 | 1 | 0 | 1 | 1 | 0.008 |
| large_03_random.json | 30 | 69 | 30 | 30 | 69 | 30 | 30 | 0.077 |
| medium_01_mixed.json | 12 | 46 | 1 | 1 | 0 | 1 | 1 | 0.009 |
| medium_02_dense.json | 14 | 127 | 1 | 1 | 0 | 1 | 1 | 0.008 |
| medium_03_sparse.json | 11 | 22 | 11 | 11 | 22 | 11 | 11 | 0.023 |
| small_01_dag.json | 6 | 7 | 6 | 6 | 7 | 6 | 6 | 0.014 |
| small_02_cycle.json | 6 | 18 | 1 | 1 | 0 | 1 | 1 | 0.006 |
| small_03_mixed.json | 8 | 22 | 1 | 1 | 0 | 1 | 1 | 0.010 |

---

## 3. Analysis

### 3.1 Tarjan’s SCC Algorithm
**Time Complexity:** O(V + E)

- On **dense cyclic graphs**, SCC count collapsed to 1, confirming correct detection of strong connectivity.
- On **sparse DAGs**, each node was an independent SCC (≈ V components), as expected.
- Bottleneck observed in **stack operations and recursion** for deeper DFS trees, but negligible for n < 1000.
- **Tarjan** was extremely stable, consistent runtimes below 1 ms for all tested graphs.

**Observation:**  
Graphs with many SCCs produce a condensed DAG close to the original graph in size (e.g., sparse cases).  
This slightly increases processing time for the following topological sort.

---

### 3.2 Kahn’s Topological Sort
**Time Complexity:** O(V + E)

- For DAGs and condensed graphs (from Tarjan), the algorithm showed linear-time behavior.
- **Dense graphs** with a single SCC (non-DAG) required only one iteration (since condensation produced one node).
- Push/pop counts match node counts — verifying correct queue operations.
- Minimal memory overhead (using queue-based approach).

**Bottleneck:** None significant for tested sizes; only queue initialization contributes minor overhead.

---

### 3.3 DAG Shortest and Longest Paths
**Time Complexity:** O(V + E)

- Both algorithms rely on the **topological order** generated by Kahn.
- **Shortest Path:** Performance is dominated by edge relaxation; on dense DAGs, this phase is slightly faster because fewer edges are skipped.
- **Longest Path:** More sensitive to DAG depth — longer chains increase relaxation passes.
- **Critical paths** appear in sparse, chain-like graphs (e.g., `large_01_perf_sparse.json`), where the path covers nearly all vertices.

**Observation:**  
On cyclic graphs, both algorithms correctly terminated early (no DAG-SP computation possible).

---

### 3.4 Structural Effects (Density, SCC Sizes)
| Structure | SCC Behavior | Topo Behavior | DAG-SP Impact |
|------------|---------------|---------------|----------------|
| Sparse DAG | Many SCCs (≈ V) | Full ordering required | Longest critical paths |
| Dense Cyclic | One SCC | Condensed DAG = single node | No DAG-SP possible |
| Mixed | Partial collapse into small SCC groups | Medium topological complexity | Balanced runtimes |
| Random | Unpredictable, near-average | Stable runtime | Intermediate path lengths |

**Key takeaway:**  
Graph **density** strongly affects SCC structure, which in turn changes the **condensed DAG** size and topological sorting time.

---

## 4. Conclusions & Practical Recommendations

### When to Use Each Algorithm
| Algorithm | Best for | Notes |
|------------|-----------|-------|
| **Tarjan (SCC)** | Detecting strongly connected structures in arbitrary directed graphs | Linear-time, recursive; sensitive to deep recursion depth |
| **Kahn (Topo)** | Producing valid topological order for DAGs or condensed graphs | Iterative and stable, works efficiently for sparse and dense DAGs |
| **DAG Shortest Path** | Fastest for acyclic weighted graphs | Outperforms Dijkstra when no cycles exist |
| **DAG Longest Path** | Identifying critical chains in scheduling, pipelines | Only valid for DAGs; grows linearly with path depth |

### ⚙️ Practical Insights
- Combine **Tarjan → Kahn → DAG-SP** as a pipeline for any directed graph.  
- **Sparse DAGs** have longer critical paths and are more informative for longest-path analysis.  
- **Dense cyclic graphs** simplify to one SCC; skip DAG-SP to save computation.
- For large graphs (n > 10⁴), iterative (non-recursive) Tarjan variants are preferable to avoid stack overflows.

---

### Summary
All algorithms demonstrated near-linear performance with sub-millisecond runtimes on all datasets.  
Structural differences (density and SCC size distribution) are the primary source of performance variance, not algorithmic inefficiency.

---

**Student:** Nurbek Shagarbek 
**Course:** DAA — Assignment 4  
**Topic:** SCC, Topo Sort, and DAG Path Analysis (Tarjan + Kahn)
